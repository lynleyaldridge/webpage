---
title: "More experimenting with SQL in R Markdown: Pivoting data,
  outputting results to R, and creating a summary table using gt"
author: Lynley Aldridge
date: '2021-01-30'
tags:
  - Rstats
  - SQL
  - gt
  - Tutorial
  - TidyTuesday
draft: yes
slug: experimenting-with-sql-in-r-markdown-more-join-queries
lastmod: '2021-01-30T20:01:24+11:00'
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
---

Following on from my [previous post](/2021/01/13/experimenting-with-sql/), I use SELECT and JOIN statements to pivot the Taylor Swift and Beyoncé Tidy Tuesday data using RSQLite, output the results to R, and create a relatively simple summary table using gt. 

# Setup

As in the previous post, load packages, read in data, set-up a connection to the database and copy in the data, and clean release dates:

```{r setup, message = FALSE}

#load packages
library(tidyverse)
library(odbc)
library(DBI)
library(RSQLite)
library(gt) # for tables

#load data
sales <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2020/2020-09-29/sales.csv')
charts <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2020/2020-09-29/charts.csv')

#create connection to database and copy data into database
con <- dbConnect(RSQLite::SQLite(), ":memory:")
copy_to(con, sales)
copy_to(con, charts)

#clean release dates as per previous post
dbExecute(con, "
UPDATE charts
SET released = TRIM(SUBSTR(released, 1, INSTR(released, ' (')))
WHERE INSTR(released, ' (')>0; 
                          ")
```

# Previewing tables using SELECT and LIMIT queries 

Let's quickly refresh our understanding of how this data is structured. 

```{r}
dbGetQuery(con, '
SELECT artist, title, country, sales, released
FROM sales
LIMIT 5
                          ')
```

```{r}
dbGetQuery(con, '
SELECT artist, title, chart, chart_position, released
FROM charts
LIMIT 5
                          ')
```

# Pivoting sales data using SELECT WHERE and JOIN queries

Please note that I am working with RSQLite in these examples in order to learn more about using SQL in R, rather than presenting this as the best way to conduct these analyses.

## Revising simple JOIN queries

First, let's review the JOIN query we used in the previous post to combine data from the charts and sales tables:

```{r revise-join}
dbGetQuery(con, '
SELECT charts.artist, charts.title, SUBSTR(charts.released, -4) as released, charts.chart, charts.chart_position as position, sales.sales  
FROM charts
LEFT JOIN sales
ON charts.chart = sales.country and
charts.title = sales.title
WHERE charts.chart IN ("US", "UK")
ORDER BY charts.artist DESC, released ASC
LIMIT 5
                          ')
```

## Pivoting sales data using SELECT WHERE and JOIN queries

To pivot data so that sales data for each country is presented in a new column (using RSQLite), we can use a series of SELECT and JOIN statements. 
The code below offers a simple illustration, using SELECT WHERE statements (in parentheses) to SELECT relevant rows (i.e., `SELECT artist, title, chart_position FROM charts WHERE chart = "US"` as a temporary table called `US_charts`) and SELECT and JOIN statements to combine extracted columns from the specified temporary tables with the sales and charts tables. (This code was created for sqlite using modified examples from [Peruz and Jeremy Field](https://stackoverflow.com/questions/37170958/how-do-i-pivot-values-into-columns-with-sqlite) on stackoverflow.) Note that specific code for pivoting data varies depending on SQL vendor, and Microsoft SQL server uses [PIVOT and UNPIVOT](https://docs.microsoft.com/en-us/sql/t-sql/queries/from-using-pivot-and-unpivot?view=sql-server-ver15) operators. 

We can also add calculated fields to this query to show what percentage of each album's  worldwide sales was comprised by sales in a specified country (e.g., `SELECT US_sales.sales/WW_sales.sales*100 AS US_percent` creates a `US_percent` column, by dividing US sales by worldwide sales, then multiplying by 100). The `round()` wrapper rounds the result of the formula defining `US_percent` to the number of decimal points specified after the comma. Note that column names included in calculations must be specified in full (e.g., `US_sales.sales`), and not by aliases that will not be assigned until the SELECT statement runs (e.g., `US_sales`).

What follows should be seen as a proof of concept, which I've used to extract just US charts and sales data:

```{r, sales-simple}
dbGetQuery(con, '
SELECT charts.artist, charts.title, SUBSTR(charts.released, -4) AS year, 
  US_charts.chart_position as US_chart,
  US_sales.sales AS US_sales, 
  WW_sales.sales AS WW_sales, 
  round(US_sales.sales/WW_sales.sales*100, 1) AS US_percent
FROM charts
LEFT JOIN (SELECT artist, title, chart_position FROM charts WHERE chart = "US") AS US_charts
ON charts.title = US_charts.title
LEFT JOIN sales
ON charts.chart = sales.country and charts.title = sales.title
LEFT JOIN (SELECT artist, title, sales FROM sales WHERE country = "US") AS US_sales
  ON sales.title = US_sales.title
LEFT JOIN (SELECT artist, title, sales FROM sales WHERE country = "WW" OR country = "World") AS WW_sales
  ON sales.title = WW_sales.title
GROUP BY charts.artist, charts.title
ORDER BY charts.artist DESC, year ASC;
                          ')
```

## Using SQL directly in R Markdown code chunks, and outputting for manipulation in R

What if I now want to output this data to R to use in a prettily formatted table or figure in an R Markdown report?  In the following code chunk, I draw on [Andrew Couch's tutorial](https://www.youtube.com/watch?v=zAgTlZUugUE) again, to write SQL code directly into the R Markdown code chunk (by replacing the `{R}` prefix with the following `{sql, connection = con, output.var = "df"}`. The first part of this statement tells R Markdown that the chunk uses SQL code and specifies the connection to access the database. The second part of the statement (`output.var = "df"`) is used to save output as a dataframe named df.

The query below uses the same statements as the example above, but captures UK and US data, and adds a new column (`other_sales`) calculating sales in countries other than the US and UK.  

```{sql, connection = con, output.var = "df"}

SELECT charts.artist, charts.title, SUBSTR(charts.released, -4) AS year, 
  US_charts.chart_position AS US_chart,
  UK_charts.chart_position AS UK_chart,
  round(US_sales.sales/1000000, 1) AS US_sales, 
  round(UK_sales.sales/1000000, 1) AS UK_sales, 
  round(WW_sales.sales/1000000, 1) AS WW_sales, 
  round((WW_sales.sales - US_sales.sales - UK_sales.sales)/1000000, 1) AS other_sales,
  round(US_sales.sales/WW_sales.sales*100, 1) AS US_percent,
  round(UK_sales.sales/WW_sales.sales*100, 1) AS UK_percent,
  round((WW_sales.sales - US_sales.sales - UK_sales.sales)/WW_sales.sales*100, 1) AS other_percent
FROM charts
LEFT JOIN (SELECT artist, title, chart_position FROM charts WHERE chart = "US") AS US_charts
  ON charts.title = US_charts.title
LEFT JOIN (SELECT artist, title, chart_position FROM charts WHERE chart = "UK") AS UK_charts
  ON charts.title = UK_charts.title
LEFT JOIN sales
  ON charts.chart = sales.country and charts.title = sales.title
LEFT JOIN (SELECT artist, title, sales FROM sales WHERE country = "US") AS US_sales
  ON sales.title = US_sales.title
LEFT JOIN (SELECT artist, title, sales FROM sales WHERE country = "UK") AS UK_sales
  ON sales.title = UK_sales.title
LEFT JOIN (SELECT artist, title, sales FROM sales WHERE country = "WW" OR country = "World") AS WW_sales
  ON sales.title = WW_sales.title
GROUP BY charts.artist, charts.title
ORDER BY charts.artist DESC, year ASC;
```

Let's look at the output:

```{r}
head(df)
```

# Creating a simple summary table using gt

There are a plethora of packages capable of creating high quality tables in R Markdown reports. Some resources for exploring these options can be found on my [resources](/../../../../resources) page. As the purpose of this particular blog post is primarily to explore the use of SQL in R Markdown, I've made a relatively simple table here. In creating this table (using gt as shown below) I drew on:

* [the package documentation for gt](https://blog.rstudio.com/2020/04/08/great-looking-tables-gt-0-2/) 

* specific instructions for [creating summary lines](https://gt.rstudio.com/articles/creating-summary-lines.html) in gt

* [10+ guidelines for better tables in R](https://themockup.blog/posts/2020-09-04-10-table-rules-in-r/), in which Thomas Mock adapts for R (using gt) tables used as examples in Jon Schwabish's [Ten guidelines for better tables](https://www.cambridge.org/core/journals/journal-of-benefit-cost-analysis/article/ten-guidelines-for-better-tables/74C6FD9FEB12038A52A95B9FBCA05A12) 

* code used by [gkaramanis](https://github.com/gkaramanis/tidytuesday/blob/master/2020-week40/beyonce-swift.R) to make a far more involved table using gt to professionally display this data 


```{r}

# define functions used to exclude NA values from total calculations
# source: https://gt.rstudio.com/articles/creating-summary-lines.html

fns_labels <- list(Total = ~sum(., na.rm = TRUE))


# start with the data exported from SQL database

df %>%
  
  # select variables to include in table  
  select(title, artist, year, US_chart, UK_chart, US_sales, WW_sales, 
          US_percent) %>%
  
  # create a table using gt, grouping by artist and using title for row name
  gt(rowname_col = "title", groupname_col = "artist") %>%
  
    # set column labels 
    cols_label(
      year = "Released",
      US_chart = "US",
      UK_chart = "UK",
      US_sales = "US",
      WW_sales = "WW",
      US_percent = "US sales (%)") %>%

   # transform NA values in all columns to "-"
    text_transform(
      locations = cells_body(columns = gt::everything()),
      fn = function(x) {
      str_replace(x, "NA", "–")
      }
    ) %>%
  
    # create headings spanning multiple columns
    tab_spanner(label = "Chart position", columns = vars(US_chart, 
                                                         UK_chart)) %>%
    tab_spanner(label = "Sales ($ million)", columns = vars(US_sales,
                                                            WW_sales)) %>%

    # align specified cells (containing numeric values) right
    cols_align(align = "right", columns = c("US_chart", "UK_chart",
                                            "US_sales", "WW_sales",
                                            "US_percent")) %>%

    # create title and subtitle for table, use md formatting
    tab_header(
      title = md("**Taylor Swift has higher sales than Beyoncé, but owes a greater proportion of her success to US sales than Beyoncé**"),
      subtitle = md("*Peak chart position, sales, and US sales as a percentage of total sales by album*"))%>%
  
    # create summary rows for each group 
    summary_rows(groups = TRUE, 
                 columns = vars(US_sales, WW_sales),
                 fns = fns_labels) %>%

    # create source note for table
    tab_source_note("Source: Wikipedia, October 2020") 

```

## One more SQL trick: UPDATE query using nested REPLACE statements

In an upcoming blog post, I plan to further refine this summary table using the `gt` package, and to use `ggplot2` and `ggflags` to graph data by country. But first, we need to update country codes in our data to be consistent with those used in `ggflags`.

Last time we worked with this data, we updated the country field to use 'WW' consistently to reflect worldwide sales. Let's update multiple country codes at once, using nested replace statements based on a suggestion from [Turophile](https://stackoverflow.com/questions/28493238/how-to-replace-multiple-words-in-sqlite-database-using-update-query) on stackoverflow.

```{r message = FALSE}
dbExecute(con, "
UPDATE sales
SET country = REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(country, 'World', 'WW'), 'AUS', 'AU'), 'JPN', 'JP'), 'UK', 'GB'), 'CAN', 'CA'), 'FRA', 'FR');
                          ")
```

## Next steps

As outlined above, the next steps for this particular project for me are to further refine my output table using `gt` (I'm wanting to include a barplot visualizing US sales as a percentage of total sales), and using `ggplot2` and `ggflags` to create bar plots showing sales data by country, assigning a flag to each bar.  Once again, however, these are questions for a future post. 

## Finally, remember to disconnect

At the end of this process, best practice is always to disconnect from the database.

```{r}
dbDisconnect(con)
```